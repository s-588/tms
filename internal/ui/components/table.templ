package components

import (
	"fmt"
	"strings"
	"time"
)

type TableColumn struct {
	Field    string
	Label    string
	Sortable bool
}

// Reusable table header component
templ TableHeader(columns []TableColumn, currentSort, currentOrder string, baseURL string) {
	<thead>
		<tr>
			<th><input type="checkbox" id={ "select-all-" + baseURL } onchange={ templ.JSFuncCall("toggleAllCheckboxes", baseURL) }/></th>
			for _, col := range columns {
				<th>
					if col.Sortable {
						<a href={ fmt.Sprintf("%s?sort=%s&order=%s", baseURL, col.Field, GetSortOrder(col.Field, currentSort, currentOrder)) }>
							{ col.Label } { GetSortIcon(col.Field, currentSort, currentOrder) }
						</a>
					} else {
						{ col.Label }
					}
				</th>
			}
			<th>Actions</th>
		</tr>
	</thead>
}

// Reusable action buttons for table rows
templ ActionButtons(entityType string, id int32, hasDetailView bool) {
	<div class="buttons are-small is-justify-content-end">
		<button
			class="button is-info is-outlined"
			title={ fmt.Sprintf("Edit %s", entityType) }
			hx-get={ fmt.Sprintf("/%s/%d/edit", entityType, id) }
			hx-push-url="true"
			hx-target="#modal-container"
			hx-swap="innerHTML"
		>
			<span class="icon"><i class="fas fa-edit"></i></span>
		</button>
		<button
			class="button is-danger is-outlined"
			title={ fmt.Sprintf("Delete %s", entityType) }
			hx-delete={ fmt.Sprintf("/%s/%d", entityType, id) }
			hx-target="closest tr"
			hx-swap="outerHTML swap:1s"
			hx-confirm={ fmt.Sprintf("Are you sure you want to delete this %s?", entityType) }
		>
			<span class="icon"><i class="fas fa-trash"></i></span>
		</button>
		if hasDetailView {
			<a
				class="button is-link is-outlined"
				title="View details"
				href={ fmt.Sprintf("/%s/%d", entityType, id) }
			>
				<span class="icon"><i class="fas fa-eye"></i></span>
			</a>
		}
	</div>
}

// Reusable operations bar
/*

templ OperationsBar(entityType string, singularName string, filter models.Filter) {
	<div class="level mb-5">
		<div class="level-left">
			<div class="level-item">
				<button
					class="button is-primary"
					hx-get={ fmt.Sprintf("/%s/new", entityType) }
					hx-target="#modal-container"
					hx-push-url="true"
				>
					<span class="icon"><i class="fas fa-plus"></i></span>
					<span>{ fmt.Sprintf("New %s", singularName) }</span>
				</button>
			</div>
			<div class="level-item">
				<button
					class="button is-danger"
					id="delete-selected"
					hx-delete={ fmt.Sprintf("/%s", entityType) }
					hx-include={ fmt.Sprintf("[name='selected_ids']:checked") }
					hx-target={ fmt.Sprintf("#%s-table", entityType) }
					hx-confirm={ fmt.Sprintf("Are you sure you want to delete selected %s?", entityType) }
				>
					<span class="icon"><i class="fas fa-trash"></i></span>
					<span>Delete Selected</span>
				</button>
			</div>
			<div class="level-item">
				<button
					class="button is-info"
					hx-get={ fmt.Sprintf("/%s/export?%s", entityType, filter.ToQueryString()) }
					hx-target="_blank"
				>
					<span class="icon"><i class="fas fa-download"></i></span>
					<span>Export</span>
				</button>
			</div>
		</div>
	</div>
}

*/

// Reusable empty state component
templ EmptyState(iconClass, message string) {
	<tr>
		<td colspan="100%" class="has-text-centered py-6">
			<div class="content">
				<span class="icon is-large has-text-grey-light">
					<i class={ fmt.Sprintf("fas %s fa-2x", iconClass) }></i>
				</span>
				<p class="mt-3 has-text-grey">{ message }</p>
			</div>
		</td>
	</tr>
}

// Reusable timestamp cell
templ TimestampCell(timestamp time.Time) {
	<time datetime={ timestamp.Format(time.RFC3339) } title={ timestamp.Format("Jan 2, 2006 15:04:05") }>
		{ timestamp.Format("2006-01-02") }
	</time>
}

type BadgeConfig struct {
	Class string
	Icon  string
	Label string
}

// Reusable badge/status cell
templ StatusBadge(status string, statusMap map[string]BadgeConfig) {
	if config, ok := statusMap[status]; ok {
		<span class={ fmt.Sprintf("tag %s", config.Class) }>
			if config.Icon != "" {
				<span class="icon is-small">
					<i class={ fmt.Sprintf("fas %s", config.Icon) }></i>
				</span>
			}
			<span>{ config.Label }</span>
		</span>
	} else {
		<span class="tag is-light">{ status }</span>
	}
}

func GetStatusColor(status string) string {
	switch strings.ToLower(status) {
	case "pending":
		return "is-warning"
	case "processing":
		return "is-info"
	case "in_transit":
		return "is-primary"
	case "delivered":
		return "is-success"
	case "cancelled":
		return "is-danger"
	default:
		return "is-light"
	}
}

// Table header with search functionality
templ TableHeaderWithSearch(title, resourceName, baseURL string, showCreateButton bool, totalCount int, searchQuery string) {
	<div class="box mb-5">
		<div class="level">
			<div class="level-left">
				<div class="level-item">
					<div>
						<h1 class="title is-3">{ title }</h1>
						if totalCount > 0 {
							<p class="subtitle is-6 has-text-grey">
								{ totalCount } { resourceName }
							</p>
						} else {
							<p class="subtitle is-6 has-text-grey">
								No records found
							</p>
						}
					</div>
				</div>
			</div>
			<div class="level-right">
				<div class="level-item" id="search-form">
					// Search form
					<form
						class="field has-addons"
						hx-get={ baseURL }
						hx-target="#table-content"
						hx-swap="innerHTML"
						hx-trigger="submit, search from:input"
					>
						<div class="control">
							<input
								class="input"
								type="search"
								name="q"
								placeholder={ fmt.Sprintf("Search %s...", resourceName) }
								value={ searchQuery }
								hx-trigger="keyup changed delay:500ms"
							/>
						</div>
						<div class="control">
							<button type="submit" class="button is-info">
								<span class="icon">
									<i class="fas fa-search"></i>
								</span>
							</button>
						</div>
					</form>
				</div>
			</div>
		</div>
		<div class="level">
			<div class="level-left">
				<div class="level-item">
					// Filters (example)
					<div class="field is-grouped">
						<div class="control">
							<div class="select is-small">
								<select
									name="status"
									hx-get={ baseURL }
									hx-target="#main-content"
									hx-swap="innerHTML"
									hx-trigger="change"
								>
									<option value="">All Statuses</option>
									<option value="active">Active</option>
									<option value="inactive">Inactive</option>
								</select>
							</div>
						</div>
						<div class="control">
							<div class="select is-small">
								<select
									name="sort"
									hx-get={ baseURL }
									hx-target="#main-content"
									hx-swap="innerHTML"
									hx-trigger="change"
								>
									<option value="created_at:desc">Newest First</option>
									<option value="created_at:asc">Oldest First</option>
									<option value="name:asc">Name A-Z</option>
									<option value="name:desc">Name Z-A</option>
								</select>
							</div>
						</div>
					</div>
				</div>
			</div>
			<div class="level-right">
				<div class="level-item">
					<div class="buttons">
						// Refresh button
						<button
							class="button is-light is-small"
							title="Refresh"
							hx-get={ baseURL }
							hx-target="#main-content"
							hx-swap="innerHTML"
						>
							<span class="icon">
								<i class="fas fa-sync-alt"></i>
							</span>
						</button>
						// Create button
						if showCreateButton {
							<button
								class="button is-primary is-small"
								title={ fmt.Sprintf("Create new %s", title) }
								hx-get={ baseURL + "/new" }
								hx-target="#modal-container"
								hx-swap="innerHTML"
							>
								<span class="icon">
									<i class="fas fa-plus"></i>
								</span>
								<span>Create</span>
							</button>
						}
					</div>
				</div>
			</div>
		</div>
	</div>
}

// Reusable date range filter
templ DateRangeFilter(label, fromName, toName string, fromValue, toValue time.Time) {
	<div class="field">
		<label class="label is-small">{ label }</label>
		<div class="field-body">
			<div class="field">
				<div class="control">
					<input class="input is-small" type="date" name={ fromName } value={ fromValue.Format(time.DateTime) }/>
				</div>
			</div>
			<div class="field">
				<div class="control">
					<input class="input is-small" type="date" name={ toName } value={ toValue.Format(time.DateTime) }/>
				</div>
			</div>
		</div>
	</div>
}

// Reusable text filter
templ TextFilter(label, name, placeholder, value string) {
	<div class="field">
		<label class="label is-small">{ label }</label>
		<div class="control">
			<input class="input is-small" type="text" name={ name } placeholder={ placeholder } value={ value }/>
		</div>
	</div>
}

func GetSortOrder(field, currentSort, currentOrder string) string {
	if currentSort == field {
		if currentOrder == "asc" {
			return "desc"
		}
		return "asc"
	}
	return "asc"
}

func GetSortIcon(field, currentSort, currentOrder string) string {
	if currentSort == field {
		if currentOrder == "asc" {
			return "↑"
		}
		return "↓"
	}
	return ""
}
