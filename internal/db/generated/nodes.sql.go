// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: nodes.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bulkHardDeleteNodes = `-- name: BulkHardDeleteNodes :exec
DELETE FROM nodes WHERE node_id = ANY($1::int[])
`

func (q *Queries) BulkHardDeleteNodes(ctx context.Context, ids []int32) error {
	_, err := q.db.Exec(ctx, bulkHardDeleteNodes, ids)
	return err
}

const bulkSoftDeleteNodes = `-- name: BulkSoftDeleteNodes :exec
UPDATE nodes SET deleted_at = NOW() WHERE node_id = ANY($1::int[])
`

func (q *Queries) BulkSoftDeleteNodes(ctx context.Context, ids []int32) error {
	_, err := q.db.Exec(ctx, bulkSoftDeleteNodes, ids)
	return err
}

const createNode = `-- name: CreateNode :one
INSERT INTO nodes (
    name, geom
) VALUES (
    $1::text,
    $2::point
)
RETURNING node_id, name, geom, created_at, updated_at, deleted_at
`

type CreateNodeParams struct {
	Name *string
	Geom pgtype.Point
}

func (q *Queries) CreateNode(ctx context.Context, arg CreateNodeParams) (Node, error) {
	row := q.db.QueryRow(ctx, createNode, arg.Name, arg.Geom)
	var i Node
	err := row.Scan(
		&i.NodeID,
		&i.Name,
		&i.Geom,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getNode = `-- name: GetNode :one
SELECT node_id, name, geom, created_at, updated_at, deleted_at FROM nodes
WHERE node_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetNode(ctx context.Context, nodeID int32) (Node, error) {
	row := q.db.QueryRow(ctx, getNode, nodeID)
	var i Node
	err := row.Scan(
		&i.NodeID,
		&i.Name,
		&i.Geom,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getNodes = `-- name: GetNodes :many
SELECT node_id, name, geom, created_at, updated_at, deleted_at,
       count(*) OVER() AS total_count
FROM nodes
WHERE deleted_at IS NULL
  AND ($1::text IS NULL OR name ILIKE '%' || $1::text || '%')
  AND ($2::timestamptz IS NULL OR created_at >= $2::timestamptz)
  AND ($3::timestamptz IS NULL OR created_at <= $3::timestamptz)
  AND ($4::timestamptz IS NULL OR updated_at >= $4::timestamptz)
  AND ($5::timestamptz IS NULL OR updated_at <= $5::timestamptz)
ORDER BY
    CASE WHEN $6::text = 'ASC' THEN
        CASE $7::text
            WHEN 'node_id' THEN node_id::text
            WHEN 'name' THEN name
            WHEN 'created_at' THEN created_at::text
            WHEN 'updated_at' THEN updated_at::text
        END
    END ASC,
    CASE WHEN $6::text = 'DESC' THEN
        CASE $7::text
            WHEN 'node_id' THEN node_id::text
            WHEN 'name' THEN name
            WHEN 'created_at' THEN created_at::text
            WHEN 'updated_at' THEN updated_at::text
        END
    END DESC
LIMIT $9 OFFSET $8
`

type GetNodesParams struct {
	NameFilter  *string
	CreatedFrom pgtype.Timestamptz
	CreatedTo   pgtype.Timestamptz
	UpdatedFrom pgtype.Timestamptz
	UpdatedTo   pgtype.Timestamptz
	SortOrder   *string
	SortBy      *string
	Offset      int32
	Limit       int32
}

type GetNodesRow struct {
	NodeID     int32
	Name       *string
	Geom       pgtype.Point
	CreatedAt  pgtype.Timestamptz
	UpdatedAt  pgtype.Timestamptz
	DeletedAt  pgtype.Timestamptz
	TotalCount int64
}

func (q *Queries) GetNodes(ctx context.Context, arg GetNodesParams) ([]GetNodesRow, error) {
	rows, err := q.db.Query(ctx, getNodes,
		arg.NameFilter,
		arg.CreatedFrom,
		arg.CreatedTo,
		arg.UpdatedFrom,
		arg.UpdatedTo,
		arg.SortOrder,
		arg.SortBy,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNodesRow
	for rows.Next() {
		var i GetNodesRow
		if err := rows.Scan(
			&i.NodeID,
			&i.Name,
			&i.Geom,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hardDeleteNode = `-- name: HardDeleteNode :exec
DELETE FROM nodes WHERE node_id = $1
`

func (q *Queries) HardDeleteNode(ctx context.Context, nodeID int32) error {
	_, err := q.db.Exec(ctx, hardDeleteNode, nodeID)
	return err
}

const restoreNode = `-- name: RestoreNode :exec
UPDATE nodes SET deleted_at = NULL WHERE node_id = $1
`

func (q *Queries) RestoreNode(ctx context.Context, nodeID int32) error {
	_, err := q.db.Exec(ctx, restoreNode, nodeID)
	return err
}

const softDeleteNode = `-- name: SoftDeleteNode :exec
UPDATE nodes SET deleted_at = NOW() WHERE node_id = $1
`

func (q *Queries) SoftDeleteNode(ctx context.Context, nodeID int32) error {
	_, err := q.db.Exec(ctx, softDeleteNode, nodeID)
	return err
}

const updateNode = `-- name: UpdateNode :exec
UPDATE nodes
SET
    name = COALESCE($1::text, name),
    geom = COALESCE($2::point, geom),
    updated_at = NOW()
WHERE node_id = $3
`

type UpdateNodeParams struct {
	Name   *string
	Geom   pgtype.Point
	NodeID int32
}

func (q *Queries) UpdateNode(ctx context.Context, arg UpdateNodeParams) error {
	_, err := q.db.Exec(ctx, updateNode, arg.Name, arg.Geom, arg.NodeID)
	return err
}
