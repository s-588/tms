// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: clients.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const bulkHardDeleteClients = `-- name: BulkHardDeleteClients :exec
DELETE FROM clients WHERE client_id = ANY($1::int[])
`

func (q *Queries) BulkHardDeleteClients(ctx context.Context, dollar_1 []int32) error {
	_, err := q.db.Exec(ctx, bulkHardDeleteClients, dollar_1)
	return err
}

const bulkSoftDeleteClients = `-- name: BulkSoftDeleteClients :exec
UPDATE clients SET deleted_at = NOW() WHERE client_id = ANY($1::int[])
`

func (q *Queries) BulkSoftDeleteClients(ctx context.Context, dollar_1 []int32) error {
	_, err := q.db.Exec(ctx, bulkSoftDeleteClients, dollar_1)
	return err
}

const createClient = `-- name: CreateClient :one
INSERT INTO clients (
    name,
    email,
    phone
) VALUES (
    $1::text,
    $2::text,
    $3::text
)
RETURNING client_id, name, email, email_verified, email_token, email_token_expiration, phone, score, created_at, updated_at, deleted_at
`

type CreateClientParams struct {
	Name  string
	Email string
	Phone string
}

func (q *Queries) CreateClient(ctx context.Context, arg CreateClientParams) (Client, error) {
	row := q.db.QueryRow(ctx, createClient, arg.Name, arg.Email, arg.Phone)
	var i Client
	err := row.Scan(
		&i.ClientID,
		&i.Name,
		&i.Email,
		&i.EmailVerified,
		&i.EmailToken,
		&i.EmailTokenExpiration,
		&i.Phone,
		&i.Score,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getClient = `-- name: GetClient :one
SELECT client_id, name, email, email_verified, email_token, email_token_expiration, phone, score, created_at, updated_at, deleted_at FROM clients
WHERE client_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetClient(ctx context.Context, clientID int32) (Client, error) {
	row := q.db.QueryRow(ctx, getClient, clientID)
	var i Client
	err := row.Scan(
		&i.ClientID,
		&i.Name,
		&i.Email,
		&i.EmailVerified,
		&i.EmailToken,
		&i.EmailTokenExpiration,
		&i.Phone,
		&i.Score,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getClientByEmail = `-- name: GetClientByEmail :one
SELECT client_id, name, email, email_verified, email_token, email_token_expiration, phone, score, created_at, updated_at, deleted_at FROM clients
WHERE email = $1 AND deleted_at IS NULL
`

func (q *Queries) GetClientByEmail(ctx context.Context, email string) (Client, error) {
	row := q.db.QueryRow(ctx, getClientByEmail, email)
	var i Client
	err := row.Scan(
		&i.ClientID,
		&i.Name,
		&i.Email,
		&i.EmailVerified,
		&i.EmailToken,
		&i.EmailTokenExpiration,
		&i.Phone,
		&i.Score,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getClientOrders = `-- name: GetClientOrders :many
SELECT o.order_id, o.client_id, o.transport_id, o.employee_id, o.price_id, o.grade, o.distance, o.weight, o.total_price, o.status, o.node_id_start, o.node_id_end, o.created_at, o.updated_at, o.deleted_at,
       count(*) OVER() AS total_count
FROM orders o
WHERE o.client_id = $3 AND o.deleted_at IS NULL
ORDER BY o.created_at DESC
LIMIT $1 OFFSET $2
`

type GetClientOrdersParams struct {
	Limit    int32
	Offset   int32
	ClientID int32
}

type GetClientOrdersRow struct {
	OrderID     int32
	ClientID    int32
	TransportID int32
	EmployeeID  int32
	PriceID     int32
	Grade       int16
	Distance    int32
	Weight      int32
	TotalPrice  decimal.Decimal
	Status      OrderStatus
	NodeIDStart *int32
	NodeIDEnd   *int32
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	DeletedAt   pgtype.Timestamptz
	TotalCount  int64
}

func (q *Queries) GetClientOrders(ctx context.Context, arg GetClientOrdersParams) ([]GetClientOrdersRow, error) {
	rows, err := q.db.Query(ctx, getClientOrders, arg.Limit, arg.Offset, arg.ClientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClientOrdersRow
	for rows.Next() {
		var i GetClientOrdersRow
		if err := rows.Scan(
			&i.OrderID,
			&i.ClientID,
			&i.TransportID,
			&i.EmployeeID,
			&i.PriceID,
			&i.Grade,
			&i.Distance,
			&i.Weight,
			&i.TotalPrice,
			&i.Status,
			&i.NodeIDStart,
			&i.NodeIDEnd,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClients = `-- name: GetClients :many
SELECT client_id, name, email, email_verified, email_token, email_token_expiration, phone, score, created_at, updated_at, deleted_at,
       (count(*) OVER())/20 AS total_count
FROM clients
WHERE deleted_at IS NULL
  AND ($1::text IS NULL OR name ILIKE '%' || $1::text || '%')
  AND ($2::text IS NULL OR email ILIKE '%' || $2::text || '%')
  AND ($3::text IS NULL OR phone ILIKE '%' || $3::text || '%')
  AND ($4::boolean IS NULL OR email_verified = $4::boolean)
  AND ($5::smallint IS NULL OR score >= $5::smallint)
  AND ($6::smallint IS NULL OR score <= $6::smallint)
  AND ($7::timestamptz IS NULL OR created_at >= $7::timestamptz)
  AND ($8::timestamptz IS NULL OR created_at <= $8::timestamptz)
  AND ($9::timestamptz IS NULL OR updated_at >= $9::timestamptz)
  AND ($10::timestamptz IS NULL OR updated_at <= $10::timestamptz)
ORDER BY
    CASE WHEN $11::text = 'ASC' THEN
        CASE $12::text
            WHEN 'name' THEN name
            WHEN 'email' THEN email
            WHEN 'phone' THEN phone
            WHEN 'email_verified' THEN email_verified::text
            WHEN 'score' THEN score::text
            WHEN 'created_at' THEN created_at::text
            WHEN 'updated_at' THEN updated_at::text
        END
    END ASC,
    CASE WHEN $11::text = 'DESC' THEN
        CASE $12::text
            WHEN 'name' THEN name
            WHEN 'email' THEN email
            WHEN 'phone' THEN phone
            WHEN 'email_verified' THEN email_verified::text
            WHEN 'score' THEN score::text
            WHEN 'created_at' THEN created_at::text
            WHEN 'updated_at' THEN updated_at::text
        END
    END DESC
LIMIT 20 OFFSET 20*($13::integer-1)
`

type GetClientsParams struct {
	NameFilter          *string
	EmailFilter         *string
	PhoneFilter         *string
	EmailVerifiedFilter *bool
	ScoreMinFilter      *int16
	ScoreMaxFilter      *int16
	CreatedFromFilter   pgtype.Timestamptz
	CreatedToFilter     pgtype.Timestamptz
	UpdatedFromFilter   pgtype.Timestamptz
	UpdatedToFilter     pgtype.Timestamptz
	SortOrder           *string
	SortBy              *string
	Page                int32
}

type GetClientsRow struct {
	ClientID             int32
	Name                 string
	Email                string
	EmailVerified        bool
	EmailToken           *string
	EmailTokenExpiration pgtype.Timestamptz
	Phone                string
	Score                int16
	CreatedAt            pgtype.Timestamptz
	UpdatedAt            pgtype.Timestamptz
	DeletedAt            pgtype.Timestamptz
	TotalCount           int32
}

func (q *Queries) GetClients(ctx context.Context, arg GetClientsParams) ([]GetClientsRow, error) {
	rows, err := q.db.Query(ctx, getClients,
		arg.NameFilter,
		arg.EmailFilter,
		arg.PhoneFilter,
		arg.EmailVerifiedFilter,
		arg.ScoreMinFilter,
		arg.ScoreMaxFilter,
		arg.CreatedFromFilter,
		arg.CreatedToFilter,
		arg.UpdatedFromFilter,
		arg.UpdatedToFilter,
		arg.SortOrder,
		arg.SortBy,
		arg.Page,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClientsRow
	for rows.Next() {
		var i GetClientsRow
		if err := rows.Scan(
			&i.ClientID,
			&i.Name,
			&i.Email,
			&i.EmailVerified,
			&i.EmailToken,
			&i.EmailTokenExpiration,
			&i.Phone,
			&i.Score,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hardDeleteClient = `-- name: HardDeleteClient :exec
DELETE FROM clients WHERE client_id = $1
`

func (q *Queries) HardDeleteClient(ctx context.Context, clientID int32) error {
	_, err := q.db.Exec(ctx, hardDeleteClient, clientID)
	return err
}

const restoreClient = `-- name: RestoreClient :exec
UPDATE clients SET deleted_at = NULL WHERE client_id = $1
`

func (q *Queries) RestoreClient(ctx context.Context, clientID int32) error {
	_, err := q.db.Exec(ctx, restoreClient, clientID)
	return err
}

const setEmailVerificationToken = `-- name: SetEmailVerificationToken :exec
UPDATE clients
SET
    email_token = $1::text,
    email_token_expiration = $2::timestamptz
WHERE client_id = $3
`

type SetEmailVerificationTokenParams struct {
	EmailToken           string
	EmailTokenExpiration pgtype.Timestamptz
	ClientID             int32
}

func (q *Queries) SetEmailVerificationToken(ctx context.Context, arg SetEmailVerificationTokenParams) error {
	_, err := q.db.Exec(ctx, setEmailVerificationToken, arg.EmailToken, arg.EmailTokenExpiration, arg.ClientID)
	return err
}

const softDeleteClient = `-- name: SoftDeleteClient :exec
UPDATE clients SET deleted_at = NOW() WHERE client_id = $1
`

func (q *Queries) SoftDeleteClient(ctx context.Context, clientID int32) error {
	_, err := q.db.Exec(ctx, softDeleteClient, clientID)
	return err
}

const updateClient = `-- name: UpdateClient :exec
UPDATE clients
SET
    name = COALESCE($1::text, name),
    email = COALESCE($2::text, email),
    phone = COALESCE($3::text, phone),
    updated_at = NOW()
WHERE client_id = $4
`

type UpdateClientParams struct {
	Name     *string
	Email    *string
	Phone    *string
	ClientID int32
}

func (q *Queries) UpdateClient(ctx context.Context, arg UpdateClientParams) error {
	_, err := q.db.Exec(ctx, updateClient,
		arg.Name,
		arg.Email,
		arg.Phone,
		arg.ClientID,
	)
	return err
}

const verifyClientEmail = `-- name: VerifyClientEmail :exec
UPDATE clients
SET
    email_verified = true,
    email_token = NULL,
    email_token_expiration = NULL
WHERE email_token = $1
`

func (q *Queries) VerifyClientEmail(ctx context.Context, emailToken *string) error {
	_, err := q.db.Exec(ctx, verifyClientEmail, emailToken)
	return err
}
