// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: orders.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const bulkHardDeleteOrders = `-- name: BulkHardDeleteOrders :exec
DELETE FROM orders WHERE order_id = ANY($1::int[])
`

func (q *Queries) BulkHardDeleteOrders(ctx context.Context, ids []int32) error {
	_, err := q.db.Exec(ctx, bulkHardDeleteOrders, ids)
	return err
}

const bulkSoftDeleteOrders = `-- name: BulkSoftDeleteOrders :exec
UPDATE orders SET deleted_at = NOW() WHERE order_id = ANY($1::int[])
`

func (q *Queries) BulkSoftDeleteOrders(ctx context.Context, ids []int32) error {
	_, err := q.db.Exec(ctx, bulkSoftDeleteOrders, ids)
	return err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (
    client_id, transport_id, employee_id, grade,
    distance, weight, total_price, price_id, status,
    node_id_start, node_id_end
) VALUES (
    $1::int,
    $2::int,
    $3::int,
    $4::smallint,
    $5::int,
    $6::int,
    $7::numeric,
    $8::int,
    $9::order_status,
    $10::int,
    $11::int
)
RETURNING order_id, client_id, transport_id, employee_id, price_id, grade, distance, weight, total_price, status, node_id_start, node_id_end, created_at, updated_at, deleted_at
`

type CreateOrderParams struct {
	ClientID    int32
	TransportID int32
	EmployeeID  int32
	Grade       int16
	Distance    int32
	Weight      int32
	TotalPrice  decimal.Decimal
	PriceID     int32
	Status      OrderStatus
	NodeIDStart int32
	NodeIDEnd   int32
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.ClientID,
		arg.TransportID,
		arg.EmployeeID,
		arg.Grade,
		arg.Distance,
		arg.Weight,
		arg.TotalPrice,
		arg.PriceID,
		arg.Status,
		arg.NodeIDStart,
		arg.NodeIDEnd,
	)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.ClientID,
		&i.TransportID,
		&i.EmployeeID,
		&i.PriceID,
		&i.Grade,
		&i.Distance,
		&i.Weight,
		&i.TotalPrice,
		&i.Status,
		&i.NodeIDStart,
		&i.NodeIDEnd,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getOrder = `-- name: GetOrder :one
SELECT order_id, client_id, transport_id, employee_id, price_id, grade, distance, weight, total_price, status, node_id_start, node_id_end, created_at, updated_at, deleted_at FROM orders
WHERE order_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetOrder(ctx context.Context, orderID int32) (Order, error) {
	row := q.db.QueryRow(ctx, getOrder, orderID)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.ClientID,
		&i.TransportID,
		&i.EmployeeID,
		&i.PriceID,
		&i.Grade,
		&i.Distance,
		&i.Weight,
		&i.TotalPrice,
		&i.Status,
		&i.NodeIDStart,
		&i.NodeIDEnd,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getOrders = `-- name: GetOrders :many
SELECT order_id, client_id, transport_id, employee_id, price_id, grade, distance, weight, total_price, status, node_id_start, node_id_end, created_at, updated_at, deleted_at,
       count(*) OVER() AS total_count
FROM orders
WHERE deleted_at IS NULL
  AND ($1::order_status IS NULL OR status = $1::order_status)
  AND ($2::numeric IS NULL OR total_price >= $2::numeric)
  AND ($3::numeric IS NULL OR total_price <= $3::numeric)
  AND ($4::int IS NULL OR distance >= $4::int)
  AND ($5::int IS NULL OR distance <= $5::int)
  AND ($6::int IS NULL OR weight >= $6::int)
  AND ($7::int IS NULL OR weight <= $7::int)
  AND ($8::int IS NULL OR client_id = $8::int)
  AND ($9::int IS NULL OR transport_id = $9::int)
  AND ($10::int IS NULL OR employee_id = $10::int)
  AND ($11::int IS NULL OR price_id = $11::int)
  AND ($12::smallint IS NULL OR grade >= $12::smallint)
  AND ($13::smallint IS NULL OR grade <= $13::smallint)
  AND ($14::timestamptz IS NULL OR created_at >= $14::timestamptz)
  AND ($15::timestamptz IS NULL OR created_at <= $15::timestamptz)
  AND ($16::timestamptz IS NULL OR updated_at >= $16::timestamptz)
  AND ($17::timestamptz IS NULL OR updated_at <= $17::timestamptz)
ORDER BY
    CASE WHEN $18::text = 'ASC' THEN
        CASE $19::text
            WHEN 'order_id' THEN order_id::text
            WHEN 'distance' THEN distance::text
            WHEN 'weight' THEN weight::text
            WHEN 'total_price' THEN total_price::text
            WHEN 'status' THEN status::text
            WHEN 'grade' THEN grade::text
            WHEN 'created_at' THEN created_at::text
            WHEN 'updated_at' THEN updated_at::text
        END
    END ASC,
    CASE WHEN $18::text = 'DESC' THEN
        CASE $19::text
            WHEN 'order_id' THEN order_id::text
            WHEN 'distance' THEN distance::text
            WHEN 'weight' THEN weight::text
            WHEN 'total_price' THEN total_price::text
            WHEN 'status' THEN status::text
            WHEN 'grade' THEN grade::text
            WHEN 'created_at' THEN created_at::text
            WHEN 'updated_at' THEN updated_at::text
        END
    END DESC
LIMIT $21 OFFSET $20
`

type GetOrdersParams struct {
	StatusFilter      NullOrderStatus
	TotalPriceMin     pgtype.Numeric
	TotalPriceMax     pgtype.Numeric
	DistanceMin       *int32
	DistanceMax       *int32
	WeightMin         *int32
	WeightMax         *int32
	ClientIDFilter    *int32
	TransportIDFilter *int32
	EmployeeIDFilter  *int32
	PriceIDFilter     *int32
	GradeMin          *int16
	GradeMax          *int16
	CreatedFrom       pgtype.Timestamptz
	CreatedTo         pgtype.Timestamptz
	UpdatedFrom       pgtype.Timestamptz
	UpdatedTo         pgtype.Timestamptz
	SortOrder         *string
	SortBy            *string
	Offset            int32
	Limit             int32
}

type GetOrdersRow struct {
	OrderID     int32
	ClientID    int32
	TransportID int32
	EmployeeID  int32
	PriceID     int32
	Grade       int16
	Distance    int32
	Weight      int32
	TotalPrice  decimal.Decimal
	Status      OrderStatus
	NodeIDStart *int32
	NodeIDEnd   *int32
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	DeletedAt   pgtype.Timestamptz
	TotalCount  int64
}

func (q *Queries) GetOrders(ctx context.Context, arg GetOrdersParams) ([]GetOrdersRow, error) {
	rows, err := q.db.Query(ctx, getOrders,
		arg.StatusFilter,
		arg.TotalPriceMin,
		arg.TotalPriceMax,
		arg.DistanceMin,
		arg.DistanceMax,
		arg.WeightMin,
		arg.WeightMax,
		arg.ClientIDFilter,
		arg.TransportIDFilter,
		arg.EmployeeIDFilter,
		arg.PriceIDFilter,
		arg.GradeMin,
		arg.GradeMax,
		arg.CreatedFrom,
		arg.CreatedTo,
		arg.UpdatedFrom,
		arg.UpdatedTo,
		arg.SortOrder,
		arg.SortBy,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrdersRow
	for rows.Next() {
		var i GetOrdersRow
		if err := rows.Scan(
			&i.OrderID,
			&i.ClientID,
			&i.TransportID,
			&i.EmployeeID,
			&i.PriceID,
			&i.Grade,
			&i.Distance,
			&i.Weight,
			&i.TotalPrice,
			&i.Status,
			&i.NodeIDStart,
			&i.NodeIDEnd,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hardDeleteOrder = `-- name: HardDeleteOrder :exec
DELETE FROM orders WHERE order_id = $1
`

func (q *Queries) HardDeleteOrder(ctx context.Context, orderID int32) error {
	_, err := q.db.Exec(ctx, hardDeleteOrder, orderID)
	return err
}

const restoreOrder = `-- name: RestoreOrder :exec
UPDATE orders SET deleted_at = NULL WHERE order_id = $1
`

func (q *Queries) RestoreOrder(ctx context.Context, orderID int32) error {
	_, err := q.db.Exec(ctx, restoreOrder, orderID)
	return err
}

const softDeleteOrder = `-- name: SoftDeleteOrder :exec
UPDATE orders SET deleted_at = NOW() WHERE order_id = $1
`

func (q *Queries) SoftDeleteOrder(ctx context.Context, orderID int32) error {
	_, err := q.db.Exec(ctx, softDeleteOrder, orderID)
	return err
}

const updateOrder = `-- name: UpdateOrder :exec
UPDATE orders
SET
    client_id = COALESCE($1::int, client_id),
    transport_id = COALESCE($2::int, transport_id),
    employee_id = COALESCE($3::int, employee_id),
    grade = COALESCE($4::smallint, grade),
    distance = COALESCE($5::int, distance),
    weight = COALESCE($6::int, weight),
    total_price = COALESCE($7::numeric, total_price),
    price_id = COALESCE($8::int, price_id),
    status = COALESCE($9::order_status, status),
    node_id_start = COALESCE($10::int, node_id_start),
    node_id_end = COALESCE($11::int, node_id_end),
    updated_at = NOW()
WHERE order_id = $12
`

type UpdateOrderParams struct {
	ClientID    *int32
	TransportID *int32
	EmployeeID  *int32
	Grade       *int16
	Distance    *int32
	Weight      *int32
	TotalPrice  pgtype.Numeric
	PriceID     *int32
	Status      NullOrderStatus
	NodeIDStart *int32
	NodeIDEnd   *int32
	OrderID     int32
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) error {
	_, err := q.db.Exec(ctx, updateOrder,
		arg.ClientID,
		arg.TransportID,
		arg.EmployeeID,
		arg.Grade,
		arg.Distance,
		arg.Weight,
		arg.TotalPrice,
		arg.PriceID,
		arg.Status,
		arg.NodeIDStart,
		arg.NodeIDEnd,
		arg.OrderID,
	)
	return err
}

const updateOrderStatus = `-- name: UpdateOrderStatus :exec
UPDATE orders
SET status = $1::order_status, updated_at = NOW()
WHERE order_id = $2
`

type UpdateOrderStatusParams struct {
	Status  OrderStatus
	OrderID int32
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) error {
	_, err := q.db.Exec(ctx, updateOrderStatus, arg.Status, arg.OrderID)
	return err
}
