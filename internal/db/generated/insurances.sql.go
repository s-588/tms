// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: insurances.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const bulkHardDeleteInsurances = `-- name: BulkHardDeleteInsurances :exec
DELETE FROM insurances WHERE insurance_id = ANY($1::int[])
`

func (q *Queries) BulkHardDeleteInsurances(ctx context.Context, ids []int32) error {
	_, err := q.db.Exec(ctx, bulkHardDeleteInsurances, ids)
	return err
}

const bulkSoftDeleteInsurances = `-- name: BulkSoftDeleteInsurances :exec
UPDATE insurances SET deleted_at = NOW() WHERE insurance_id = ANY($1::int[])
`

func (q *Queries) BulkSoftDeleteInsurances(ctx context.Context, ids []int32) error {
	_, err := q.db.Exec(ctx, bulkSoftDeleteInsurances, ids)
	return err
}

const createInsurance = `-- name: CreateInsurance :one
INSERT INTO insurances (
    transport_id, insurance_date, insurance_expiration, payment, coverage
) VALUES (
    $1::int,
    $2::date,
    $3::date,
    $4::numeric,
    $5::numeric
)
RETURNING insurance_id, transport_id, insurance_date, insurance_expiration, payment, coverage, created_at, updated_at, deleted_at
`

type CreateInsuranceParams struct {
	TransportID         int32
	InsuranceDate       pgtype.Date
	InsuranceExpiration pgtype.Date
	Payment             decimal.Decimal
	Coverage            decimal.Decimal
}

func (q *Queries) CreateInsurance(ctx context.Context, arg CreateInsuranceParams) (Insurance, error) {
	row := q.db.QueryRow(ctx, createInsurance,
		arg.TransportID,
		arg.InsuranceDate,
		arg.InsuranceExpiration,
		arg.Payment,
		arg.Coverage,
	)
	var i Insurance
	err := row.Scan(
		&i.InsuranceID,
		&i.TransportID,
		&i.InsuranceDate,
		&i.InsuranceExpiration,
		&i.Payment,
		&i.Coverage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getInsurance = `-- name: GetInsurance :one
SELECT insurance_id, transport_id, insurance_date, insurance_expiration, payment, coverage, created_at, updated_at, deleted_at FROM insurances
WHERE insurance_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetInsurance(ctx context.Context, insuranceID int32) (Insurance, error) {
	row := q.db.QueryRow(ctx, getInsurance, insuranceID)
	var i Insurance
	err := row.Scan(
		&i.InsuranceID,
		&i.TransportID,
		&i.InsuranceDate,
		&i.InsuranceExpiration,
		&i.Payment,
		&i.Coverage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getInsuranceByTransport = `-- name: GetInsuranceByTransport :one
SELECT insurance_id, transport_id, insurance_date, insurance_expiration, payment, coverage, created_at, updated_at, deleted_at FROM insurances
WHERE transport_id = $1 AND deleted_at IS NULL
ORDER BY insurance_expiration DESC
LIMIT 1
`

func (q *Queries) GetInsuranceByTransport(ctx context.Context, transportID int32) (Insurance, error) {
	row := q.db.QueryRow(ctx, getInsuranceByTransport, transportID)
	var i Insurance
	err := row.Scan(
		&i.InsuranceID,
		&i.TransportID,
		&i.InsuranceDate,
		&i.InsuranceExpiration,
		&i.Payment,
		&i.Coverage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getInsurances = `-- name: GetInsurances :many
SELECT insurance_id, transport_id, insurance_date, insurance_expiration, payment, coverage, created_at, updated_at, deleted_at,
       count(*) OVER() AS total_count
FROM insurances
WHERE deleted_at IS NULL
  AND ($1::int IS NULL OR transport_id = $1::int)
  AND ($2::date IS NULL OR insurance_date >= $2::date)
  AND ($3::date IS NULL OR insurance_date <= $3::date)
  AND ($4::date IS NULL OR insurance_expiration >= $4::date)
  AND ($5::date IS NULL OR insurance_expiration <= $5::date)
  AND ($6::numeric IS NULL OR payment >= $6::numeric)
  AND ($7::numeric IS NULL OR payment <= $7::numeric)
  AND ($8::numeric IS NULL OR coverage >= $8::numeric)
  AND ($9::numeric IS NULL OR coverage <= $9::numeric)
  AND ($10::timestamptz IS NULL OR created_at >= $10::timestamptz)
  AND ($11::timestamptz IS NULL OR created_at <= $11::timestamptz)
  AND ($12::timestamptz IS NULL OR updated_at >= $12::timestamptz)
  AND ($13::timestamptz IS NULL OR updated_at <= $13::timestamptz)
ORDER BY
    CASE WHEN $14::text = 'ASC' THEN
        CASE $15::text
            WHEN 'insurance_id' THEN insurance_id::text
            WHEN 'transport_id' THEN transport_id::text
            WHEN 'insurance_date' THEN insurance_date::text
            WHEN 'insurance_expiration' THEN insurance_expiration::text
            WHEN 'payment' THEN payment::text
            WHEN 'coverage' THEN coverage::text
            WHEN 'created_at' THEN created_at::text
            WHEN 'updated_at' THEN updated_at::text
        END
    END ASC,
    CASE WHEN $14::text = 'DESC' THEN
        CASE $15::text
            WHEN 'insurance_id' THEN insurance_id::text
            WHEN 'transport_id' THEN transport_id::text
            WHEN 'insurance_date' THEN insurance_date::text
            WHEN 'insurance_expiration' THEN insurance_expiration::text
            WHEN 'payment' THEN payment::text
            WHEN 'coverage' THEN coverage::text
            WHEN 'created_at' THEN created_at::text
            WHEN 'updated_at' THEN updated_at::text
        END
    END DESC
LIMIT $17 OFFSET $16
`

type GetInsurancesParams struct {
	TransportIDFilter       *int32
	InsuranceDateFrom       pgtype.Date
	InsuranceDateTo         pgtype.Date
	InsuranceExpirationFrom pgtype.Date
	InsuranceExpirationTo   pgtype.Date
	PaymentMin              pgtype.Numeric
	PaymentMax              pgtype.Numeric
	CoverageMin             pgtype.Numeric
	CoverageMax             pgtype.Numeric
	CreatedFrom             pgtype.Timestamptz
	CreatedTo               pgtype.Timestamptz
	UpdatedFrom             pgtype.Timestamptz
	UpdatedTo               pgtype.Timestamptz
	SortOrder               *string
	SortBy                  *string
	Offset                  int32
	Limit                   int32
}

type GetInsurancesRow struct {
	InsuranceID         int32
	TransportID         int32
	InsuranceDate       pgtype.Date
	InsuranceExpiration pgtype.Date
	Payment             decimal.Decimal
	Coverage            decimal.Decimal
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	DeletedAt           pgtype.Timestamptz
	TotalCount          int64
}

func (q *Queries) GetInsurances(ctx context.Context, arg GetInsurancesParams) ([]GetInsurancesRow, error) {
	rows, err := q.db.Query(ctx, getInsurances,
		arg.TransportIDFilter,
		arg.InsuranceDateFrom,
		arg.InsuranceDateTo,
		arg.InsuranceExpirationFrom,
		arg.InsuranceExpirationTo,
		arg.PaymentMin,
		arg.PaymentMax,
		arg.CoverageMin,
		arg.CoverageMax,
		arg.CreatedFrom,
		arg.CreatedTo,
		arg.UpdatedFrom,
		arg.UpdatedTo,
		arg.SortOrder,
		arg.SortBy,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInsurancesRow
	for rows.Next() {
		var i GetInsurancesRow
		if err := rows.Scan(
			&i.InsuranceID,
			&i.TransportID,
			&i.InsuranceDate,
			&i.InsuranceExpiration,
			&i.Payment,
			&i.Coverage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hardDeleteInsurance = `-- name: HardDeleteInsurance :exec
DELETE FROM insurances WHERE insurance_id = $1
`

func (q *Queries) HardDeleteInsurance(ctx context.Context, insuranceID int32) error {
	_, err := q.db.Exec(ctx, hardDeleteInsurance, insuranceID)
	return err
}

const restoreInsurance = `-- name: RestoreInsurance :exec
UPDATE insurances SET deleted_at = NULL WHERE insurance_id = $1
`

func (q *Queries) RestoreInsurance(ctx context.Context, insuranceID int32) error {
	_, err := q.db.Exec(ctx, restoreInsurance, insuranceID)
	return err
}

const softDeleteInsurance = `-- name: SoftDeleteInsurance :exec
UPDATE insurances SET deleted_at = NOW() WHERE insurance_id = $1
`

func (q *Queries) SoftDeleteInsurance(ctx context.Context, insuranceID int32) error {
	_, err := q.db.Exec(ctx, softDeleteInsurance, insuranceID)
	return err
}

const updateInsurance = `-- name: UpdateInsurance :exec
UPDATE insurances
SET
    transport_id = COALESCE($1::int, transport_id),
    insurance_date = COALESCE($2::date, insurance_date),
    insurance_expiration = COALESCE($3::date, insurance_expiration),
    payment = COALESCE($4::numeric, payment),
    coverage = COALESCE($5::numeric, coverage),
    updated_at = NOW()
WHERE insurance_id = $6
`

type UpdateInsuranceParams struct {
	TransportID         *int32
	InsuranceDate       pgtype.Date
	InsuranceExpiration pgtype.Date
	Payment             pgtype.Numeric
	Coverage            pgtype.Numeric
	InsuranceID         int32
}

func (q *Queries) UpdateInsurance(ctx context.Context, arg UpdateInsuranceParams) error {
	_, err := q.db.Exec(ctx, updateInsurance,
		arg.TransportID,
		arg.InsuranceDate,
		arg.InsuranceExpiration,
		arg.Payment,
		arg.Coverage,
		arg.InsuranceID,
	)
	return err
}
