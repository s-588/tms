// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: inspections.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bulkHardDeleteInspections = `-- name: BulkHardDeleteInspections :exec
DELETE FROM inspections WHERE inspection_id = ANY($1::int[])
`

func (q *Queries) BulkHardDeleteInspections(ctx context.Context, ids []int32) error {
	_, err := q.db.Exec(ctx, bulkHardDeleteInspections, ids)
	return err
}

const bulkSoftDeleteInspections = `-- name: BulkSoftDeleteInspections :exec
UPDATE inspections SET deleted_at = NOW() WHERE inspection_id = ANY($1::int[])
`

func (q *Queries) BulkSoftDeleteInspections(ctx context.Context, ids []int32) error {
	_, err := q.db.Exec(ctx, bulkSoftDeleteInspections, ids)
	return err
}

const createInspection = `-- name: CreateInspection :one
INSERT INTO inspections (
    transport_id, inspection_date, inspection_expiration, status
) VALUES (
    $1::int,
    $2::date,
    $3::date,
    $4::inspection_status
)
RETURNING inspection_id, transport_id, inspection_date, inspection_expiration, status, created_at, updated_at, deleted_at
`

type CreateInspectionParams struct {
	TransportID          int32
	InspectionDate       pgtype.Date
	InspectionExpiration pgtype.Date
	Status               InspectionStatus
}

func (q *Queries) CreateInspection(ctx context.Context, arg CreateInspectionParams) (Inspection, error) {
	row := q.db.QueryRow(ctx, createInspection,
		arg.TransportID,
		arg.InspectionDate,
		arg.InspectionExpiration,
		arg.Status,
	)
	var i Inspection
	err := row.Scan(
		&i.InspectionID,
		&i.TransportID,
		&i.InspectionDate,
		&i.InspectionExpiration,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getInspection = `-- name: GetInspection :one
SELECT inspection_id, transport_id, inspection_date, inspection_expiration, status, created_at, updated_at, deleted_at FROM inspections
WHERE inspection_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetInspection(ctx context.Context, inspectionID int32) (Inspection, error) {
	row := q.db.QueryRow(ctx, getInspection, inspectionID)
	var i Inspection
	err := row.Scan(
		&i.InspectionID,
		&i.TransportID,
		&i.InspectionDate,
		&i.InspectionExpiration,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getInspections = `-- name: GetInspections :many
SELECT inspection_id, transport_id, inspection_date, inspection_expiration, status, created_at, updated_at, deleted_at,
       count(*) OVER() AS total_count
FROM inspections
WHERE deleted_at IS NULL
  AND ($1::int IS NULL OR transport_id = $1::int)
  AND ($2::inspection_status IS NULL OR status = $2::inspection_status)
  AND ($3::date IS NULL OR inspection_date >= $3::date)
  AND ($4::date IS NULL OR inspection_date <= $4::date)
  AND ($5::date IS NULL OR inspection_expiration >= $5::date)
  AND ($6::date IS NULL OR inspection_expiration <= $6::date)
  AND ($7::timestamptz IS NULL OR created_at >= $7::timestamptz)
  AND ($8::timestamptz IS NULL OR created_at <= $8::timestamptz)
  AND ($9::timestamptz IS NULL OR updated_at >= $9::timestamptz)
  AND ($10::timestamptz IS NULL OR updated_at <= $10::timestamptz)
ORDER BY
    CASE WHEN $11::text = 'ASC' THEN
        CASE $12::text
            WHEN 'inspection_id' THEN inspection_id::text
            WHEN 'transport_id' THEN transport_id::text
            WHEN 'status' THEN status::text
            WHEN 'inspection_date' THEN inspection_date::text
            WHEN 'inspection_expiration' THEN inspection_expiration::text
            WHEN 'created_at' THEN created_at::text
            WHEN 'updated_at' THEN updated_at::text
        END
    END ASC,
    CASE WHEN $11::text = 'DESC' THEN
        CASE $12::text
            WHEN 'inspection_id' THEN inspection_id::text
            WHEN 'transport_id' THEN transport_id::text
            WHEN 'status' THEN status::text
            WHEN 'inspection_date' THEN inspection_date::text
            WHEN 'inspection_expiration' THEN inspection_expiration::text
            WHEN 'created_at' THEN created_at::text
            WHEN 'updated_at' THEN updated_at::text
        END
    END DESC
LIMIT $14 OFFSET $13
`

type GetInspectionsParams struct {
	TransportIDFilter        *int32
	StatusFilter             NullInspectionStatus
	InspectionDateFrom       pgtype.Date
	InspectionDateTo         pgtype.Date
	InspectionExpirationFrom pgtype.Date
	InspectionExpirationTo   pgtype.Date
	CreatedFrom              pgtype.Timestamptz
	CreatedTo                pgtype.Timestamptz
	UpdatedFrom              pgtype.Timestamptz
	UpdatedTo                pgtype.Timestamptz
	SortOrder                *string
	SortBy                   *string
	Offset                   int32
	Limit                    int32
}

type GetInspectionsRow struct {
	InspectionID         int32
	TransportID          int32
	InspectionDate       pgtype.Date
	InspectionExpiration pgtype.Date
	Status               InspectionStatus
	CreatedAt            pgtype.Timestamptz
	UpdatedAt            pgtype.Timestamptz
	DeletedAt            pgtype.Timestamptz
	TotalCount           int64
}

func (q *Queries) GetInspections(ctx context.Context, arg GetInspectionsParams) ([]GetInspectionsRow, error) {
	rows, err := q.db.Query(ctx, getInspections,
		arg.TransportIDFilter,
		arg.StatusFilter,
		arg.InspectionDateFrom,
		arg.InspectionDateTo,
		arg.InspectionExpirationFrom,
		arg.InspectionExpirationTo,
		arg.CreatedFrom,
		arg.CreatedTo,
		arg.UpdatedFrom,
		arg.UpdatedTo,
		arg.SortOrder,
		arg.SortBy,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInspectionsRow
	for rows.Next() {
		var i GetInspectionsRow
		if err := rows.Scan(
			&i.InspectionID,
			&i.TransportID,
			&i.InspectionDate,
			&i.InspectionExpiration,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInspectionsByTransport = `-- name: GetInspectionsByTransport :many
SELECT inspection_id, transport_id, inspection_date, inspection_expiration, status, created_at, updated_at, deleted_at FROM inspections
WHERE transport_id = $1 AND deleted_at IS NULL
ORDER BY inspection_date DESC
`

func (q *Queries) GetInspectionsByTransport(ctx context.Context, transportID int32) ([]Inspection, error) {
	rows, err := q.db.Query(ctx, getInspectionsByTransport, transportID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Inspection
	for rows.Next() {
		var i Inspection
		if err := rows.Scan(
			&i.InspectionID,
			&i.TransportID,
			&i.InspectionDate,
			&i.InspectionExpiration,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hardDeleteInspection = `-- name: HardDeleteInspection :exec
DELETE FROM inspections WHERE inspection_id = $1
`

func (q *Queries) HardDeleteInspection(ctx context.Context, inspectionID int32) error {
	_, err := q.db.Exec(ctx, hardDeleteInspection, inspectionID)
	return err
}

const restoreInspection = `-- name: RestoreInspection :exec
UPDATE inspections SET deleted_at = NULL WHERE inspection_id = $1
`

func (q *Queries) RestoreInspection(ctx context.Context, inspectionID int32) error {
	_, err := q.db.Exec(ctx, restoreInspection, inspectionID)
	return err
}

const softDeleteInspection = `-- name: SoftDeleteInspection :exec
UPDATE inspections SET deleted_at = NOW() WHERE inspection_id = $1
`

func (q *Queries) SoftDeleteInspection(ctx context.Context, inspectionID int32) error {
	_, err := q.db.Exec(ctx, softDeleteInspection, inspectionID)
	return err
}

const updateInspection = `-- name: UpdateInspection :exec
UPDATE inspections
SET
    transport_id = COALESCE($1::int, transport_id),
    inspection_date = COALESCE($2::date, inspection_date),
    inspection_expiration = COALESCE($3::date, inspection_expiration),
    status = COALESCE($4::inspection_status, status),
    updated_at = NOW()
WHERE inspection_id = $5
`

type UpdateInspectionParams struct {
	TransportID          *int32
	InspectionDate       pgtype.Date
	InspectionExpiration pgtype.Date
	Status               NullInspectionStatus
	InspectionID         int32
}

func (q *Queries) UpdateInspection(ctx context.Context, arg UpdateInspectionParams) error {
	_, err := q.db.Exec(ctx, updateInspection,
		arg.TransportID,
		arg.InspectionDate,
		arg.InspectionExpiration,
		arg.Status,
		arg.InspectionID,
	)
	return err
}
